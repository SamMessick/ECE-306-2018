###############################################################################
#
# IAR C/C++ Compiler V7.11.1.983/W32 for MSP430           06/May/2018  22:52:34
# Copyright 1996-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 7.11
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_10\wheels.c
#    Command line  =  
#        -f C:\Users\shmes\AppData\Local\Temp\EW8949.tmp
#        ("C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_10\wheels.c" -lC
#        "C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_10\Debug\List" -o
#        "C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_10\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5994__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  Spanish_USA.1252
#    List file     =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_10\Debug\List\wheels.lst
#    Object file   =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_10\Debug\Obj\wheels.r43
#
###############################################################################

C:\Users\shmes\Desktop\Escritorio Personal\Escuela\ECE\306\ECE306\Project_10\wheels.c
      1          //===============================================================
      2          //  File Name: wheels.c
      3          //  Description: This file contains the functions needed for control
      4          //                    operations of the wheels
      5          //
      6          //  Author: Sam Messick
      7          //  Date Feb. 2018
      8          //  Compiler Build with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
      9          //===============================================================
     10          
     11          #include "wheels.h"

   \                                 In  segment DATA16_AN, at 0x342
   \   union <unnamed> _A_TA0CCTL0_L
   \                     _A_TA0CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x344
   \   union <unnamed> _A_TA0CCTL1_L
   \                     _A_TA0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x346
   \   union <unnamed> _A_TA0CCTL2_L
   \                     _A_TA0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d8
   \   union <unnamed> _A_TB0CCR3_L
   \                     _A_TB0CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3da
   \   union <unnamed> _A_TB0CCR4_L
   \                     _A_TB0CCR4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3dc
   \   union <unnamed> _A_TB0CCR5_L
   \                     _A_TB0CCR5_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3de
   \   union <unnamed> _A_TB0CCR6_L
   \                     _A_TB0CCR6_L:
   \   000000                DS8 2
     12          
     13          // H-bridge protection flags: 
     14          // don't allow for motion forward/backward simultaneously in one motor
     15          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          uint8_t left_forward_flag;     // Is left motor rotating forward?
   \                     left_forward_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          uint8_t left_reverse_flag;     // Is left motor rotating reverse?
   \                     left_reverse_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          uint8_t right_forward_flag;    // Is right motor rotating forward?
   \                     right_forward_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          uint8_t right_reverse_flag;    // Is right motor rotating reverse?
   \                     right_reverse_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          uint8_t instruction_label_tmp; // Global of current instruction step
   \                     instruction_label_tmp:
   \   000000                DS8 1

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     21          uint8_t LastDir = 3;
   \                     LastDir:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for LastDir>`
     22          
     23          //--------PID fields-----------//

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          int16_t   right_pwm;
   \                     right_pwm:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          int16_t   left_pwm;
   \                     left_pwm:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          PID ld; // Left infrared detector
   \                     ld:
   \   000000                DS8 18

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          PID rd;
   \                     rd:
   \   000000                DS8 18
     28          //-----------------------------//
     29          
     30          

   \                                 In  segment CODE, align 2
     31          void init_PID(void){
   \                     init_PID:
     32            /*
     33            ld.windup_guard = L_PWM_MAX;
     34            rd.windup_guard = R_PWM_MAX;
     35            ld.p_gain = 1.5;//((double)(ADC_Thumb))/1000;     // 1.15
     36            ld.i_gain = 0; 
     37            ld.d_gain = 6;//1.5;
     38            rd.p_gain = 3;//((double)(ADC_Thumb))/1000;
     39            rd.i_gain = 0; 
     40            rd.d_gain = 6;//1.5;
     41            right_pwm = RIGHT_FORWARD_SPEED;
     42            left_pwm = LEFT_FORWARD_SPEED;
     43          */
     44          }
   \   000000   1001         RETA
     45          

   \                                 In  segment CODE, align 2
     46          void pid_udpate_left(void){
   \                     pid_udpate_left:
     47            
     48            if(ADC_Left_Detector >= ir_black_reading)
   \   000000   9292........ CMP.W   &ir_black_reading, &ADC_Left_Detector
   \   000006   1628         JNC     ??pid_udpate_left_0
     49              if(ADC_Right_Detector >= ir_black_reading)
   \   000008   9292........ CMP.W   &ir_black_reading, &ADC_Right_Detector
   \   00000E   0828         JNC     ??pid_udpate_left_1
     50              {
     51                Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED1);
   \   000010   7C406400     MOV.B   #0x64, R12
   \   000014   ........     CALLA   #Left_Motor_ON_FORWARD
     52                Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED1);
   \   000018   7C405000     MOV.B   #0x50, R12
   \   00001C   ........     BRA     #Right_Motor_ON_FORWARD
     53              }
     54              else
     55              {
     56                Left_Motor_ON_FORWARD(LEFT_L_SEARCH_SPEED);
   \                     ??pid_udpate_left_1:
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   ........     CALLA   #Left_Motor_ON_FORWARD
     57                Right_Motor_ON_FORWARD(RIGHT_L_SEARCH_SPEED);
   \   000026   7C405000     MOV.B   #0x50, R12
   \   00002A   ........     CALLA   #Right_Motor_ON_FORWARD
     58                LastDir = GOING_LEFT;
   \   00002E   C243....     MOV.B   #0x0, &LastDir
   \   000032   1001         RETA
     59              }
     60            else 
     61              if(ADC_Right_Detector >= ir_black_reading)
   \                     ??pid_udpate_left_0:
   \   000034   9292........ CMP.W   &ir_black_reading, &ADC_Right_Detector
   \   00003A   0A28         JNC     ??pid_udpate_left_2
     62              {
     63                Left_Motor_ON_FORWARD(LEFT_R_SEARCH_SPEED);
   \   00003C   7C406400     MOV.B   #0x64, R12
   \   000040   ........     CALLA   #Left_Motor_ON_FORWARD
     64                Right_Motor_ON_FORWARD(RIGHT_R_SEARCH_SPEED);
   \   000044   4C43         MOV.B   #0x0, R12
   \   000046   ........     CALLA   #Right_Motor_ON_FORWARD
     65                LastDir = GOING_RIGHT;
   \   00004A   D243....     MOV.B   #0x1, &LastDir
   \   00004E   1001         RETA
     66              }
     67              else 
     68              {
     69                if(LastDir == GOING_RIGHT)
   \                     ??pid_udpate_left_2:
   \   000050   D293....     CMP.B   #0x1, &LastDir
   \   000054   0720         JNE     ??pid_udpate_left_3
     70                {
     71                  Left_Motor_ON_FORWARD(LEFT_R_SEARCH_SPEED);
   \   000056   7C406400     MOV.B   #0x64, R12
   \   00005A   ........     CALLA   #Left_Motor_ON_FORWARD
     72                  Right_Motor_ON_FORWARD(RIGHT_R_SEARCH_SPEED);
   \   00005E   4C43         MOV.B   #0x0, R12
   \   000060   ........     BRA     #Right_Motor_ON_FORWARD
     73                }
     74                else if(LastDir == GOING_LEFT)
   \                     ??pid_udpate_left_3:
   \   000064   C293....     CMP.B   #0x0, &LastDir
   \   000068   0720         JNE     ??pid_udpate_left_4
     75                {
     76                  Left_Motor_ON_FORWARD(LEFT_L_SEARCH_SPEED);
   \   00006A   4C43         MOV.B   #0x0, R12
   \   00006C   ........     CALLA   #Left_Motor_ON_FORWARD
     77                  Right_Motor_ON_FORWARD(RIGHT_L_SEARCH_SPEED);
   \   000070   7C405000     MOV.B   #0x50, R12
   \   000074   ........     BRA     #Right_Motor_ON_FORWARD
     78                }
     79                else
     80                {
     81                  Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \                     ??pid_udpate_left_4:
   \   000078   7C40FA00     MOV.B   #0xfa, R12
   \   00007C   ........     CALLA   #Left_Motor_ON_FORWARD
     82                  Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   000080   7C40B400     MOV.B   #0xb4, R12
   \   000084   ........     BRA     #Right_Motor_ON_FORWARD
     83                }
     84              }
     85            /*
     86            // Attempted PID
     87             Uses a PID with noise bands at ir_white_reading and 
     88             ir_black_reading, adjusting for changes to follow
     89             a black line.
     90          
     91            // Take NUM_SAMPLES from PID in pid_samples for averaging
     92            static uint8_t samp_index; 
     93            static int16_t[NUM_SAMPLES] pid_error_l_samples; 
     94            static int16_t error_l;
     95            static int16_t d_error_l;
     96            
     97            int16_t error_l_w;
     98            int16_t error_l_b;
     99            
    100            // Update PID errors
    101            error_l_w = ADC_Left_Detector - ir_white_reading;
    102            error_l_b = ADC_Left_Detector - ir_black_reading;
    103            
    104            // Check if error falls outside of noise bands
    105            if(error_l_w < 0)
    106            {
    107              error_l = error_l_w;
    108              pid_error_l_samples
    109            }
    110            else if(error_l_b > 0)
    111              error_l = error_l_b;
    112            else
    113              return;
    114            
    115            
    116            
    117            if(error_l IS_POSITIVE)
    118              P1OUT  |= RED_LED;
    119            else
    120              P1OUT  &= ~RED_LED;
    121            ld.i_error = error_l + ld.i_error;
    122            d_error_l = error_l - ld.prev_error;
    123            if(d_error_l IS_POSITIVE)
    124              P1OUT  |= GRN_LED;
    125            else
    126              P1OUT  &= ~GRN_LED;
    127            
    128            if(ld.i_error > ld.windup_guard)
    129              ld.i_error = ld.windup_guard;
    130            else if(ld.i_error < -ld.windup_guard)
    131              ld.i_error = -ld.windup_guard;
    132            
    133            // Calculate adjusted pwm
    134            left_pwm =  (uint8_t)(LEFT_FORWARD_SPEED    -
    135                        (ld.p_gain * error_l) -
    136                        (ld.i_gain * ld.i_error) -
    137                        (ld.d_gain * d_error_l));
    138            right_pwm = (uint8_t)(RIGHT_FORWARD_SPEED  +
    139                        (rd.p_gain * error_l) +
    140                        (rd.i_gain * ld.i_error) +
    141                        (rd.d_gain * d_error_l));
    142            if(left_pwm > L_PWM_MAX)
    143              left_pwm = L_PWM_MAX;
    144            if(left_pwm < L_PWM_MIN)
    145              left_pwm = L_PWM_MIN;
    146            if(right_pwm > R_PWM_MAX)
    147              right_pwm = R_PWM_MAX;
    148            if(right_pwm < R_PWM_MIN)
    149              right_pwm = R_PWM_MIN;
    150            
    151            // Enable motor
    152            Left_Motor_ON_FORWARD(left_pwm);
    153            Right_Motor_ON_FORWARD(right_pwm);
    154            
    155            ld.prev_error = error_l;
    156          */
    157          }
    158          

   \                                 In  segment CODE, align 2
    159          void initialize_delay(uint16_t delay){
   \                     initialize_delay:
    160            delay_time = delay;                          // send delay time to global accessible by timer A1
   \   000000   824C....     MOV.W   R12, &delay_time
    161            TA0CCTL2 |= CCIE;                            // enable timer A1.2 to count time
   \   000004   B2D010004603 BIS.W   #0x10, &0x346
    162          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_TA0CCTL2_L
    163          

   \                                 In  segment CODE, align 2
    164          void update_instruction_label(uint8_t* instruction_label){
   \                     update_instruction_label:
    165            (*instruction_label)++;                         // Set up next instruction
   \   000000   DC530000     ADD.B   #0x1, 0(R12)
    166            instruction_label_tmp = *instruction_label;   // Set static instruction visable by menu to update LCD
   \   000004   E24C....     MOV.B   @R12, &instruction_label_tmp
    167          }
   \   000008   1001         RETA
    168          
    169          void WHEELS_test(void);
    170          //------------------------
    171          // Turning wheels off
    172          //------------------------

   \                                 In  segment CODE, align 2
    173          void Left_Motor_OFF(void){
   \                     Left_Motor_OFF:
    174            TB0CCR3 = MOTOR_OFF;         // Set PWM to 0 percent duty cycle
   \   000000   8243D803     MOV.W   #0x0, &0x3d8
    175            TB0CCR4 = MOTOR_OFF;   
   \   000004   8243DA03     MOV.W   #0x0, &0x3da
    176            left_forward_flag = left_reverse_flag = false;
   \   000008   C243....     MOV.B   #0x0, &left_reverse_flag
   \   00000C   D242........ MOV.B   &left_reverse_flag, &left_forward_flag
    177          }
   \   000012   1001         RETA
   \   000014                REQUIRE _A_TB0CCR3_L
   \   000014                REQUIRE _A_TB0CCR4_L

   \                                 In  segment CODE, align 2
    178          void Right_Motor_OFF(void){
   \                     Right_Motor_OFF:
    179            TB0CCR5 = MOTOR_OFF;         // Set PWM to 0 percent duty cycle
   \   000000   8243DC03     MOV.W   #0x0, &0x3dc
    180            TB0CCR6 = MOTOR_OFF;         
   \   000004   8243DE03     MOV.W   #0x0, &0x3de
    181            right_forward_flag = right_reverse_flag = false;
   \   000008   C243....     MOV.B   #0x0, &right_reverse_flag
   \   00000C   D242........ MOV.B   &right_reverse_flag, &right_forward_flag
    182          }
   \   000012   1001         RETA
   \   000014                REQUIRE _A_TB0CCR5_L
   \   000014                REQUIRE _A_TB0CCR6_L

   \                                 In  segment CODE, align 2
    183          void Wheels_OFF(void){
   \                     Wheels_OFF:
    184            Left_Motor_OFF();
   \   000000   ........     CALLA   #Left_Motor_OFF
    185            Right_Motor_OFF();
   \   000004   ........     BRA     #Right_Motor_OFF
    186          }
    187          
    188          //------------------------
    189          // Turning wheels on
    190          //------------------------
    191          //**********
    192          // Forward *
    193          //**********

   \                                 In  segment CODE, align 2
    194          void Left_Motor_ON_FORWARD(uint8_t speed){
   \                     Left_Motor_ON_FORWARD:
    195            if(!left_reverse_flag)                         // If left motor is not set to move backward already
   \   000000   C293....     CMP.B   #0x0, &left_reverse_flag
   \   000004   0A20         JNE     ??Left_Motor_ON_FORWARD_0
    196            {
    197              TB0CCR4 = speed*DUTY_CYCLE_DIVISOR;         // Set left motor forward speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDA03     MOV.W   R15, &0x3da
    198              left_forward_flag = true;                   // Prevent left motor from moving backward simultaneously
   \   000016   D243....     MOV.B   #0x1, &left_forward_flag
    199            }
    200          }
   \                     ??Left_Motor_ON_FORWARD_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR4_L
    201          

   \                                 In  segment CODE, align 2
    202          void Right_Motor_ON_FORWARD(uint8_t speed){
   \                     Right_Motor_ON_FORWARD:
    203            if(!right_reverse_flag)                        // If right motor is not set to move backward already
   \   000000   C293....     CMP.B   #0x0, &right_reverse_flag
   \   000004   0A20         JNE     ??Right_Motor_ON_FORWARD_0
    204            { 
    205              TB0CCR6 = speed*DUTY_CYCLE_DIVISOR;         // Set right motor forward speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDE03     MOV.W   R15, &0x3de
    206              right_forward_flag = true;                  // Prevent right motor from moving backward simultaneously
   \   000016   D243....     MOV.B   #0x1, &right_forward_flag
    207            }
    208          }
   \                     ??Right_Motor_ON_FORWARD_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR6_L
    209          

   \                                 In  segment CODE, align 2
    210          void Drive_Straight_Forward(uint8_t speed){
   \                     Drive_Straight_Forward:
   \   000000   4D4C         MOV.B   R12, R13
    211            Left_Motor_ON_FORWARD(speed);
   \   000002   4C4D         MOV.B   R13, R12
   \   000004   ........     CALLA   #Left_Motor_ON_FORWARD
    212            Right_Motor_ON_FORWARD(speed);
   \   000008   4C4D         MOV.B   R13, R12
   \   00000A   ........     BRA     #Right_Motor_ON_FORWARD
    213          }
    214            
    215          //**********
    216          // Reverse *
    217          //**********

   \                                 In  segment CODE, align 2
    218          void Left_Motor_ON_REVERSE(uint8_t speed){
   \                     Left_Motor_ON_REVERSE:
    219            if(!left_forward_flag)                        // If left motor is not set to move forward already
   \   000000   C293....     CMP.B   #0x0, &left_forward_flag
   \   000004   0A20         JNE     ??Left_Motor_ON_REVERSE_0
    220            { 
    221              TB0CCR3 = speed*DUTY_CYCLE_DIVISOR;         // Set left motor reverse speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FD803     MOV.W   R15, &0x3d8
    222              left_reverse_flag = true;                   // Prevent left motor from moving forward simultaneously
   \   000016   D243....     MOV.B   #0x1, &left_reverse_flag
    223            }
    224          }
   \                     ??Left_Motor_ON_REVERSE_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR3_L
    225          

   \                                 In  segment CODE, align 2
    226          void Right_Motor_ON_REVERSE(char speed){
   \                     Right_Motor_ON_REVERSE:
    227            if(!right_forward_flag)                       // If right motor is not set to move forward already
   \   000000   C293....     CMP.B   #0x0, &right_forward_flag
   \   000004   0A20         JNE     ??Right_Motor_ON_REVERSE_0
    228            {
    229              TB0CCR5 = speed*DUTY_CYCLE_DIVISOR;         // Set right motor reverse speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDC03     MOV.W   R15, &0x3dc
    230              right_reverse_flag = true;                  // Prevent right motor from moving forward simultaneously
   \   000016   D243....     MOV.B   #0x1, &right_reverse_flag
    231            }
    232          }
   \                     ??Right_Motor_ON_REVERSE_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR5_L
    233          

   \                                 In  segment CODE, align 2
    234          void turn(uint8_t degrees){
   \                     turn:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   484C         MOV.B   R12, R8
    235            uint32_t time_ms_temp;
    236            
    237            if(degrees == LEAVE_COURSE)
   \   000004   78902D00     CMP.B   #0x2d, R8
   \   000008   3A20         JNE     ??turn_8
    238            {
    239              time_ms_temp = time_ms;
   \   00000A   1A42....     MOV.W   &time_ms, R10
   \   00000E   1B42....     MOV.W   &time_ms + 2, R11
    240              LCD_print(" Exiting  ", word2, word3, word4);
   \   000012   1F42....     MOV.W   &word4, R15
   \   000016   1E42....     MOV.W   &word3, R14
   \   00001A   1D42....     MOV.W   &word2, R13
   \   00001E   3C40....     MOV.W   #`?<Constant " Exiting  ">`, R12
   \   000022   ........     CALLA   #LCD_print
    241              Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   000026   7C40FA00     MOV.B   #0xfa, R12
   \   00002A   ........     CALLA   #Left_Motor_ON_FORWARD
    242              Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   00002E   7C40B400     MOV.B   #0xb4, R12
   \   000032   ........     CALLA   #Right_Motor_ON_FORWARD
    243              while(time_ms - time_ms_temp < EXIT_TIME);     // Drive forward for x seconds
   \                     ??turn_0:
   \   000036   1E42....     MOV.W   &time_ms, R14
   \   00003A   1F42....     MOV.W   &time_ms + 2, R15
   \   00003E   0E8A         SUB.W   R10, R14
   \   000040   0F7B         SUBC.W  R11, R15
   \   000042   0F93         CMP.W   #0x0, R15
   \   000044   F82B         JNC     ??turn_0
   \   000046   0320         JNE     ??turn_9
   \   000048   3E90D007     CMP.W   #0x7d0, R14
   \   00004C   F42B         JNC     ??turn_0
    244          
    245              Wheels_OFF();                                  // Stop car
   \                     ??turn_9:
   \   00004E   ........     CALLA   #Wheels_OFF
    246              TA0CCTL0 &= ~CCIE;                             // Disable timer interrupts
   \   000052   B2C010004203 BIC.W   #0x10, &0x342
    247              TA0CCTL1 &= ~CCIE;                             // Disable button interrupts
   \   000058   B2C010004403 BIC.W   #0x10, &0x344
    248              LCD_print("P10 Finit ", word2, "  ^____^  ", "          ");
   \   00005E   3F40....     MOV.W   #`?<Constant "          ">`, R15
   \   000062   3E40....     MOV.W   #`?<Constant "  ^____^  ">`, R14
   \   000066   1D42....     MOV.W   &word2, R13
   \   00006A   3C40....     MOV.W   #`?<Constant "P10 Finit ">`, R12
   \   00006E   ........     CALLA   #LCD_print
    249              waiting = true;
   \   000072   D243....     MOV.B   #0x1, &waiting
    250              while(waiting);                                // Do nothing
   \                     ??turn_1:
   \   000076   C293....     CMP.B   #0x0, &waiting
   \   00007A   FD23         JNE     ??turn_1
   \   00007C   613C         JMP     ??turn_7
    251            }
    252            else
    253            {
    254              delay_time = LONG_DELAY;
   \                     ??turn_8:
   \   00007E   B240EE02.... MOV.W   #0x2ee, &delay_time
    255              Wheels_OFF();
   \   000084   ........     CALLA   #Wheels_OFF
    256              waiting = true;
   \   000088   D243....     MOV.B   #0x1, &waiting
    257              TA0CCTL2 |= CCIE;
   \   00008C   B2D010004603 BIS.W   #0x10, &0x346
    258              while(waiting);
   \                     ??turn_2:
   \   000092   C293....     CMP.B   #0x0, &waiting
   \   000096   FD23         JNE     ??turn_2
    259              delay_time = SHORT_DELAY;
   \   000098   B240FA00.... MOV.W   #0xfa, &delay_time
    260              LCD_print("", word2, word3, word4);
   \   00009E   1F42....     MOV.W   &word4, R15
   \   0000A2   1E42....     MOV.W   &word3, R14
   \   0000A6   1D42....     MOV.W   &word2, R13
   \   0000AA   3C40....     MOV.W   #`?<Constant "">`, R12
   \   0000AE   ........     CALLA   #LCD_print
    261              Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   0000B2   7C40FA00     MOV.B   #0xfa, R12
   \   0000B6   ........     CALLA   #Left_Motor_ON_FORWARD
    262              Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   0000BA   7C40B400     MOV.B   #0xb4, R12
   \   0000BE   ........     CALLA   #Right_Motor_ON_FORWARD
    263              waiting = true;
   \   0000C2   D243....     MOV.B   #0x1, &waiting
    264              TA0CCTL2 |= CCIE;
   \   0000C6   B2D010004603 BIS.W   #0x10, &0x346
    265              while(waiting);
   \                     ??turn_3:
   \   0000CC   C293....     CMP.B   #0x0, &waiting
   \   0000D0   FD23         JNE     ??turn_3
    266              delay_time = SHORT_DELAY;
   \   0000D2   B240FA00.... MOV.W   #0xfa, &delay_time
    267              Wheels_OFF();
   \   0000D8   ........     CALLA   #Wheels_OFF
    268              waiting = true;
   \   0000DC   D243....     MOV.B   #0x1, &waiting
    269              TA0CCTL2 |= CCIE;
   \   0000E0   B2D010004603 BIS.W   #0x10, &0x346
    270              while(waiting);
   \                     ??turn_4:
   \   0000E6   C293....     CMP.B   #0x0, &waiting
   \   0000EA   FD23         JNE     ??turn_4
    271              delay_time = LONG_DELAY;
   \   0000EC   B240EE02.... MOV.W   #0x2ee, &delay_time
    272              LCD_print("Turning in", word2, word3, word4);
   \   0000F2   1F42....     MOV.W   &word4, R15
   \   0000F6   1E42....     MOV.W   &word3, R14
   \   0000FA   1D42....     MOV.W   &word2, R13
   \   0000FE   3C40....     MOV.W   #`?<Constant "Turning in">`, R12
   \   000102   ........     CALLA   #LCD_print
    273              Left_Motor_ON_REVERSE(LEFT_SPIN_SPEED);
   \   000106   7C40FD00     MOV.B   #0xfd, R12
   \   00010A   ........     CALLA   #Left_Motor_ON_REVERSE
    274              Right_Motor_ON_FORWARD(RIGHT_SPIN_SPEED);
   \   00010E   7C40FD00     MOV.B   #0xfd, R12
   \   000112   ........     CALLA   #Right_Motor_ON_FORWARD
    275              waiting = true;
   \   000116   D243....     MOV.B   #0x1, &waiting
    276              TA0CCTL2 |= CCIE;
   \   00011A   B2D010004603 BIS.W   #0x10, &0x346
    277              while(waiting);
   \                     ??turn_5:
   \   000120   C293....     CMP.B   #0x0, &waiting
   \   000124   FD23         JNE     ??turn_5
    278              delay_time = SHORT_DELAY;
   \   000126   B240FA00.... MOV.W   #0xfa, &delay_time
    279              Wheels_OFF();
   \   00012C   ........     CALLA   #Wheels_OFF
    280              waiting = true;
   \   000130   D243....     MOV.B   #0x1, &waiting
    281              TA0CCTL2 |= CCIE;
   \   000134   B2D010004603 BIS.W   #0x10, &0x346
    282              while(waiting);
   \                     ??turn_6:
   \   00013A   C293....     CMP.B   #0x0, &waiting
   \   00013E   FD23         JNE     ??turn_6
    283            }
    284          }
   \                     ??turn_7:
   \   000140   3817         POPM.W  #0x4, R11
   \   000142   1001         RETA
   \   000144                REQUIRE _A_TA0CCTL0_L
   \   000144                REQUIRE _A_TA0CCTL1_L
   \   000144                REQUIRE _A_TA0CCTL2_L
    285          

   \                                 In  segment CODE, align 2
    286          void drive_to_black_line(void){
   \                     drive_to_black_line:
   \   000000   1B15         PUSHM.W #0x2, R11
    287            uint32_t time_ms_temp = time_ms;
   \   000002   1A42....     MOV.W   &time_ms, R10
   \   000006   1B42....     MOV.W   &time_ms + 2, R11
    288            Wheels_OFF();
   \   00000A   ........     CALLA   #Wheels_OFF
    289            LCD_print("Searching", word2, word3, word4);
   \   00000E   1F42....     MOV.W   &word4, R15
   \   000012   1E42....     MOV.W   &word3, R14
   \   000016   1D42....     MOV.W   &word2, R13
   \   00001A   3C40....     MOV.W   #`?<Constant "Searching">`, R12
   \   00001E   ........     CALLA   #LCD_print
    290            
    291            Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   000022   7C40FA00     MOV.B   #0xfa, R12
   \   000026   ........     CALLA   #Left_Motor_ON_FORWARD
    292            Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   00002A   7C40B400     MOV.B   #0xb4, R12
   \   00002E   ........     CALLA   #Right_Motor_ON_FORWARD
    293            while(time_ms - time_ms_temp < TWO_SEC);
   \                     ??drive_to_black_line_0:
   \   000032   1E42....     MOV.W   &time_ms, R14
   \   000036   1F42....     MOV.W   &time_ms + 2, R15
   \   00003A   0E8A         SUB.W   R10, R14
   \   00003C   0F7B         SUBC.W  R11, R15
   \   00003E   0F93         CMP.W   #0x0, R15
   \   000040   F82B         JNC     ??drive_to_black_line_0
   \   000042   0320         JNE     ??drive_to_black_line_3
   \   000044   3E90D007     CMP.W   #0x7d0, R14
   \   000048   F42B         JNC     ??drive_to_black_line_0
    294            LCD_print("SearchingW", word2, word3, word4);
   \                     ??drive_to_black_line_3:
   \   00004A   1F42....     MOV.W   &word4, R15
   \   00004E   1E42....     MOV.W   &word3, R14
   \   000052   1D42....     MOV.W   &word2, R13
   \   000056   3C40....     MOV.W   #`?<Constant "SearchingW">`, R12
   \   00005A   ........     CALLA   #LCD_print
    295            while(ADC_Left_Detector > ir_white_reading          // Drive to white surface
    296               || ADC_Right_Detector > ir_white_reading)
   \                     ??drive_to_black_line_1:
   \   00005E   9292........ CMP.W   &ADC_Left_Detector, &ir_white_reading
   \   000064   0428         JNC     ??drive_to_black_line_4
   \   000066   9292........ CMP.W   &ADC_Right_Detector, &ir_white_reading
   \   00006C   032C         JC      ??drive_to_black_line_5
    297            {
    298              update_ir_reading();
   \                     ??drive_to_black_line_4:
   \   00006E   ........     CALLA   #update_ir_reading
   \   000072   F53F         JMP     ??drive_to_black_line_1
    299            }
    300            LCD_print("SearchingB", word2, word3, word4);
   \                     ??drive_to_black_line_5:
   \   000074   1F42....     MOV.W   &word4, R15
   \   000078   1E42....     MOV.W   &word3, R14
   \   00007C   1D42....     MOV.W   &word2, R13
   \   000080   3C40....     MOV.W   #`?<Constant "SearchingB">`, R12
   \   000084   ........     CALLA   #LCD_print
    301            while(ADC_Left_Detector < ir_black_reading          // Drive to black line
    302               && ADC_Right_Detector < ir_black_reading)
   \                     ??drive_to_black_line_2:
   \   000088   9292........ CMP.W   &ir_black_reading, &ADC_Left_Detector
   \   00008E   072C         JC      ??drive_to_black_line_6
   \   000090   9292........ CMP.W   &ir_black_reading, &ADC_Right_Detector
   \   000096   032C         JC      ??drive_to_black_line_6
    303            {
    304              update_ir_reading();
   \   000098   ........     CALLA   #update_ir_reading
   \   00009C   F53F         JMP     ??drive_to_black_line_2
    305            }
    306            Wheels_OFF();                                       // Stop car on black line
   \                     ??drive_to_black_line_6:
   \   00009E   ........     CALLA   #Wheels_OFF
    307          }
   \   0000A2   1A17         POPM.W  #0x2, R11
   \   0000A4   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for LastDir>`:
   \   000000   03           DC8 3

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " Exiting  ">`:
   \   000000   204578697469 DC8 " Exiting  "
   \            6E67202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "P10 Finit ">`:
   \   000000   503130204669 DC8 "P10 Finit "
   \            6E69742000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  ^____^  ">`:
   \   000000   20205E5F5F5F DC8 "  ^____^  "
   \            5F5E202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "">`:
   \   000000   00           DC8 ""

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Turning in">`:
   \   000000   5475726E696E DC8 "Turning in"
   \            6720696E00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Searching">`:
   \   000000   536561726368 DC8 "Searching"
   \            696E6700    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "SearchingW">`:
   \   000000   536561726368 DC8 "SearchingW"
   \            696E675700  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "SearchingB">`:
   \   000000   536561726368 DC8 "SearchingB"
   \            696E674200  
    308            
    309            
    310            
    311            
    312            
    313            
    314            
    315            
    316            
    317              //Backup Code 
    318            /*
    319            if(ADC_Left_Detector < ir_active_reading && ADC_Right_Detector > ir_active_reading)
    320            {
    321              left_pwm += 120;
    322              if(left_pwm > L_PWM_MAX)
    323              left_pwm = L_PWM_MAX;
    324              Left_Motor_ON_FORWARD(left_pwm);
    325              right_pwm -= 100;
    326              if(right_pwm < R_PWM_MIN)
    327              right_pwm = R_PWM_MIN;
    328              Right_Motor_ON_FORWARD(right_pwm);
    329            }
    330            else
    331            {
    332              right_pwm += 160;
    333              if(right_pwm > R_PWM_MAX)
    334              right_pwm = R_PWM_MAX;
    335              Right_Motor_ON_FORWARD(right_pwm);
    336              left_pwm -= 120;
    337              if(left_pwm < L_PWM_MIN)
    338              left_pwm = L_PWM_MIN;
    339              Left_Motor_ON_FORWARD(left_pwm);
    340            }
    341          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive_Straight_Forward
        4   -> Left_Motor_ON_FORWARD
        0   -> Right_Motor_ON_FORWARD
      4   Left_Motor_OFF
      4   Left_Motor_ON_FORWARD
      4   Left_Motor_ON_REVERSE
      4   Right_Motor_OFF
      4   Right_Motor_ON_FORWARD
      4   Right_Motor_ON_REVERSE
      4   Wheels_OFF
        4   -> Left_Motor_OFF
        0   -> Right_Motor_OFF
      8   drive_to_black_line
        8   -> LCD_print
        8   -> Left_Motor_ON_FORWARD
        8   -> Right_Motor_ON_FORWARD
        8   -> Wheels_OFF
        8   -> update_ir_reading
      4   init_PID
      4   initialize_delay
      4   pid_udpate_left
        4   -> Left_Motor_ON_FORWARD
        0   -> Right_Motor_ON_FORWARD
        4   -> Right_Motor_ON_FORWARD
     12   turn
       12   -> LCD_print
       12   -> Left_Motor_ON_FORWARD
       12   -> Left_Motor_ON_REVERSE
       12   -> Right_Motor_ON_FORWARD
       12   -> Wheels_OFF
      4   update_instruction_label


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
      11  ?<Constant "  ^____^  ">
      11  ?<Constant " Exiting  ">
       1  ?<Constant "">
      11  ?<Constant "P10 Finit ">
      10  ?<Constant "Searching">
      11  ?<Constant "SearchingB">
      11  ?<Constant "SearchingW">
      11  ?<Constant "Turning in">
       1  ?<Initializer for LastDir>
      14  Drive_Straight_Forward
       1  LastDir
      20  Left_Motor_OFF
      28  Left_Motor_ON_FORWARD
      28  Left_Motor_ON_REVERSE
      20  Right_Motor_OFF
      28  Right_Motor_ON_FORWARD
      28  Right_Motor_ON_REVERSE
       8  Wheels_OFF
       2  _A_TA0CCTL0_L
       2  _A_TA0CCTL1_L
       2  _A_TA0CCTL2_L
       2  _A_TB0CCR3_L
       2  _A_TB0CCR4_L
       2  _A_TB0CCR5_L
       2  _A_TB0CCR6_L
     166  drive_to_black_line
       2  init_PID
      12  initialize_delay
       1  instruction_label_tmp
      18  ld
       1  left_forward_flag
       2  left_pwm
       1  left_reverse_flag
     136  pid_udpate_left
      18  rd
       1  right_forward_flag
       2  right_pwm
       1  right_reverse_flag
     324  turn
      10  update_instruction_label

 
 824 bytes in segment CODE
  14 bytes in segment DATA16_AN
  88 bytes in segment DATA16_C
   1 byte  in segment DATA16_I
   1 byte  in segment DATA16_ID
  45 bytes in segment DATA16_Z
 
 824 bytes of CODE  memory
  89 bytes of CONST memory
  46 bytes of DATA  memory (+ 14 bytes shared)

Errors: none
Warnings: none
