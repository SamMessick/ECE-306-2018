###############################################################################
#
# IAR C/C++ Compiler V7.11.1.983/W32 for MSP430           26/Apr/2018  12:33:57
# Copyright 1996-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 7.11
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\wheels.c
#    Command line  =  
#        -f C:\Users\shmes\AppData\Local\Temp\EW34A5.tmp
#        ("C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\wheels.c" -lC
#        "C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\List" -o
#        "C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5994__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  Spanish_USA.1252
#    List file     =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\List\wheels.lst
#    Object file   =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\Obj\wheels.r43
#
###############################################################################

C:\Users\shmes\Desktop\Escritorio Personal\Escuela\ECE\306\ECE306\Project_09\wheels.c
      1          //===============================================================
      2          //  File Name: wheels.c
      3          //  Description: This file contains the functions needed for control
      4          //                    operations of the wheels
      5          //
      6          //  Author: Sam Messick
      7          //  Date Feb. 2018
      8          //  Compiler Build with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
      9          //===============================================================
     10          
     11          #include "wheels.h"

   \                                 In  segment DATA16_AN, at 0x800
   \   union <unnamed> _A_ADC12CTL0_L
   \                     _A_ADC12CTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x812
   \   union <unnamed> _A_ADC12IER0_L
   \                     _A_ADC12IER0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x342
   \   union <unnamed> _A_TA0CCTL0_L
   \                     _A_TA0CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x344
   \   union <unnamed> _A_TA0CCTL1_L
   \                     _A_TA0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x346
   \   union <unnamed> _A_TA0CCTL2_L
   \                     _A_TA0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d8
   \   union <unnamed> _A_TB0CCR3_L
   \                     _A_TB0CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3da
   \   union <unnamed> _A_TB0CCR4_L
   \                     _A_TB0CCR4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3dc
   \   union <unnamed> _A_TB0CCR5_L
   \                     _A_TB0CCR5_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3de
   \   union <unnamed> _A_TB0CCR6_L
   \                     _A_TB0CCR6_L:
   \   000000                DS8 2
     12          
     13          // H-bridge protection flags: 
     14          // don't allow for motion forward/backward simultaneously in one motor
     15          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          uint8_t left_forward_flag;     // Is left motor rotating forward?
   \                     left_forward_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          uint8_t left_reverse_flag;     // Is left motor rotating reverse?
   \                     left_reverse_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          uint8_t right_forward_flag;    // Is right motor rotating forward?
   \                     right_forward_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          uint8_t right_reverse_flag;    // Is right motor rotating reverse?
   \                     right_reverse_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          uint8_t instruction_label_tmp; // Global of current instruction step
   \                     instruction_label_tmp:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          uint8_t LastDir;
   \                     LastDir:
   \   000000                DS8 1
     22          
     23          //--------PID fields-----------//

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          int16_t   right_pwm;
   \                     right_pwm:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          int16_t   left_pwm;
   \                     left_pwm:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          PID ld; // Left infrared detector
   \                     ld:
   \   000000                DS8 18

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          PID rd;
   \                     rd:
   \   000000                DS8 18
     28          //-----------------------------//
     29          
     30          

   \                                 In  segment CODE, align 2
     31          void Init_PID(void){
   \                     Init_PID:
     32            /*
     33            ld.windup_guard = L_PWM_MAX;
     34            rd.windup_guard = R_PWM_MAX;
     35            ld.p_gain = 1.5;//((double)(ADC_Thumb))/1000;     // 1.15
     36            ld.i_gain = 0; 
     37            ld.d_gain = 6;//1.5;
     38            rd.p_gain = 3;//((double)(ADC_Thumb))/1000;
     39            rd.i_gain = 0; 
     40            rd.d_gain = 6;//1.5;
     41            right_pwm = RIGHT_FORWARD_SPEED;
     42            left_pwm = LEFT_FORWARD_SPEED;
     43          */
     44          }
   \   000000   1001         RETA
     45          

   \                                 In  segment CODE, align 2
     46          void pid_udpate_left(void){
   \                     pid_udpate_left:
     47            
     48            if(ADC_Left_Detector >= ir_black_reading)
   \   000000   9292........ CMP.W   &ir_black_reading, &ADC_Left_Detector
   \   000006   1628         JNC     ??pid_udpate_left_0
     49              if(ADC_Right_Detector >= ir_black_reading)
   \   000008   9292........ CMP.W   &ir_black_reading, &ADC_Right_Detector
   \   00000E   0828         JNC     ??pid_udpate_left_1
     50              {
     51                Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   000010   7C40EB00     MOV.B   #0xeb, R12
   \   000014   ........     CALLA   #Left_Motor_ON_FORWARD
     52                Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   000018   7C409100     MOV.B   #0x91, R12
   \   00001C   ........     BRA     #Right_Motor_ON_FORWARD
     53              }
     54              else
     55              {
     56                Left_Motor_ON_FORWARD(LEFT_R_SEARCH_SPEED);
   \                     ??pid_udpate_left_1:
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   ........     CALLA   #Left_Motor_ON_FORWARD
     57                Right_Motor_ON_FORWARD(RIGHT_R_SEARCH_SPEED);
   \   000026   7C405000     MOV.B   #0x50, R12
   \   00002A   ........     CALLA   #Right_Motor_ON_FORWARD
     58                LastDir = GOING_LEFT;
   \   00002E   C243....     MOV.B   #0x0, &LastDir
   \   000032   1001         RETA
     59              }
     60            else 
     61              if(ADC_Right_Detector >= ir_black_reading)
   \                     ??pid_udpate_left_0:
   \   000034   9292........ CMP.W   &ir_black_reading, &ADC_Right_Detector
   \   00003A   0A28         JNC     ??pid_udpate_left_2
     62              {
     63            
     64                Left_Motor_ON_FORWARD(LEFT_L_SEARCH_SPEED);
   \   00003C   7C407800     MOV.B   #0x78, R12
   \   000040   ........     CALLA   #Left_Motor_ON_FORWARD
     65                Right_Motor_ON_FORWARD(RIGHT_L_SEARCH_SPEED);
   \   000044   4C43         MOV.B   #0x0, R12
   \   000046   ........     CALLA   #Right_Motor_ON_FORWARD
     66                LastDir = GOING_RIGHT;
   \   00004A   D243....     MOV.B   #0x1, &LastDir
   \   00004E   1001         RETA
     67              }
     68              else 
     69              {
     70                word4 = "  White   ";
   \                     ??pid_udpate_left_2:
   \   000050   B240........ MOV.W   #`?<Constant "  White   ">`, &word4
     71                if(LastDir == GOING_LEFT)
   \   000056   C293....     CMP.B   #0x0, &LastDir
   \   00005A   0720         JNE     ??pid_udpate_left_3
     72                {
     73                  Left_Motor_ON_FORWARD(LEFT_R_SEARCH_SPEED);
   \   00005C   4C43         MOV.B   #0x0, R12
   \   00005E   ........     CALLA   #Left_Motor_ON_FORWARD
     74                  Right_Motor_ON_FORWARD(RIGHT_R_SEARCH_SPEED);
   \   000062   7C405000     MOV.B   #0x50, R12
   \   000066   ........     BRA     #Right_Motor_ON_FORWARD
     75                }
     76                else
     77                {
     78                  Left_Motor_ON_FORWARD(LEFT_L_SEARCH_SPEED);
   \                     ??pid_udpate_left_3:
   \   00006A   7C407800     MOV.B   #0x78, R12
   \   00006E   ........     CALLA   #Left_Motor_ON_FORWARD
     79                  Right_Motor_ON_FORWARD(RIGHT_L_SEARCH_SPEED);
   \   000072   4C43         MOV.B   #0x0, R12
   \   000074   ........     BRA     #Right_Motor_ON_FORWARD
     80                }
     81              }
     82            /*
     83            // Attempted PID
     84             Uses a PID with noise bands at ir_white_reading and 
     85             ir_black_reading, adjusting for changes to follow
     86             a black line.
     87          
     88            // Take NUM_SAMPLES from PID in pid_samples for averaging
     89            static uint8_t samp_index; 
     90            static int16_t[NUM_SAMPLES] pid_error_l_samples; 
     91            static int16_t error_l;
     92            static int16_t d_error_l;
     93            
     94            int16_t error_l_w;
     95            int16_t error_l_b;
     96            
     97            // Update PID errors
     98            error_l_w = ADC_Left_Detector - ir_white_reading;
     99            error_l_b = ADC_Left_Detector - ir_black_reading;
    100            
    101            // Check if error falls outside of noise bands
    102            if(error_l_w < 0)
    103            {
    104              error_l = error_l_w;
    105              pid_error_l_samples
    106            }
    107            else if(error_l_b > 0)
    108              error_l = error_l_b;
    109            else
    110              return;
    111            
    112            
    113            
    114            if(error_l IS_POSITIVE)
    115              P1OUT  |= RED_LED;
    116            else
    117              P1OUT  &= ~RED_LED;
    118            ld.i_error = error_l + ld.i_error;
    119            d_error_l = error_l - ld.prev_error;
    120            if(d_error_l IS_POSITIVE)
    121              P1OUT  |= GRN_LED;
    122            else
    123              P1OUT  &= ~GRN_LED;
    124            
    125            if(ld.i_error > ld.windup_guard)
    126              ld.i_error = ld.windup_guard;
    127            else if(ld.i_error < -ld.windup_guard)
    128              ld.i_error = -ld.windup_guard;
    129            
    130            // Calculate adjusted pwm
    131            left_pwm =  (uint8_t)(LEFT_FORWARD_SPEED    -
    132                        (ld.p_gain * error_l) -
    133                        (ld.i_gain * ld.i_error) -
    134                        (ld.d_gain * d_error_l));
    135            right_pwm = (uint8_t)(RIGHT_FORWARD_SPEED  +
    136                        (rd.p_gain * error_l) +
    137                        (rd.i_gain * ld.i_error) +
    138                        (rd.d_gain * d_error_l));
    139            if(left_pwm > L_PWM_MAX)
    140              left_pwm = L_PWM_MAX;
    141            if(left_pwm < L_PWM_MIN)
    142              left_pwm = L_PWM_MIN;
    143            if(right_pwm > R_PWM_MAX)
    144              right_pwm = R_PWM_MAX;
    145            if(right_pwm < R_PWM_MIN)
    146              right_pwm = R_PWM_MIN;
    147            
    148            // Enable motor
    149            Left_Motor_ON_FORWARD(left_pwm);
    150            Right_Motor_ON_FORWARD(right_pwm);
    151            
    152            ld.prev_error = error_l;
    153          */
    154          }
    155          

   \                                 In  segment CODE, align 2
    156          void initialize_delay(uint16_t delay){
   \                     initialize_delay:
    157            delay_time = delay;                          // send delay time to global accessible by timer A1
   \   000000   824C....     MOV.W   R12, &delay_time
    158            TA0CCTL2 |= CCIE;                            // enable timer A1.2 to count time
   \   000004   B2D010004603 BIS.W   #0x10, &0x346
    159          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_TA0CCTL2_L
    160          

   \                                 In  segment CODE, align 2
    161          void update_instruction_label(uint8_t* instruction_label){
   \                     update_instruction_label:
    162            (*instruction_label)++;                         // Set up next instruction
   \   000000   DC530000     ADD.B   #0x1, 0(R12)
    163            instruction_label_tmp = *instruction_label;   // Set static instruction visable by menu to update LCD
   \   000004   E24C....     MOV.B   @R12, &instruction_label_tmp
    164          }
   \   000008   1001         RETA
    165          
    166          void WHEELS_test(void);
    167          //------------------------
    168          // Turning wheels off
    169          //------------------------

   \                                 In  segment CODE, align 2
    170          void Left_Motor_OFF(void){
   \                     Left_Motor_OFF:
    171            TB0CCR3 = MOTOR_OFF;         // Set PWM to 0 percent duty cycle
   \   000000   8243D803     MOV.W   #0x0, &0x3d8
    172            TB0CCR4 = MOTOR_OFF;   
   \   000004   8243DA03     MOV.W   #0x0, &0x3da
    173            left_forward_flag = left_reverse_flag = false;
   \   000008   C243....     MOV.B   #0x0, &left_reverse_flag
   \   00000C   D242........ MOV.B   &left_reverse_flag, &left_forward_flag
    174          }
   \   000012   1001         RETA
   \   000014                REQUIRE _A_TB0CCR3_L
   \   000014                REQUIRE _A_TB0CCR4_L

   \                                 In  segment CODE, align 2
    175          void Right_Motor_OFF(void){
   \                     Right_Motor_OFF:
    176            TB0CCR5 = MOTOR_OFF;         // Set PWM to 0 percent duty cycle
   \   000000   8243DC03     MOV.W   #0x0, &0x3dc
    177            TB0CCR6 = MOTOR_OFF;         
   \   000004   8243DE03     MOV.W   #0x0, &0x3de
    178            right_forward_flag = right_reverse_flag = false;
   \   000008   C243....     MOV.B   #0x0, &right_reverse_flag
   \   00000C   D242........ MOV.B   &right_reverse_flag, &right_forward_flag
    179          }
   \   000012   1001         RETA
   \   000014                REQUIRE _A_TB0CCR5_L
   \   000014                REQUIRE _A_TB0CCR6_L

   \                                 In  segment CODE, align 2
    180          void Wheels_OFF(void){
   \                     Wheels_OFF:
    181            Left_Motor_OFF();
   \   000000   ........     CALLA   #Left_Motor_OFF
    182            Right_Motor_OFF();
   \   000004   ........     BRA     #Right_Motor_OFF
    183          }
    184          
    185          //------------------------
    186          // Turning wheels on
    187          //------------------------
    188          //**********
    189          // Forward *
    190          //**********

   \                                 In  segment CODE, align 2
    191          void Left_Motor_ON_FORWARD(uint8_t speed){
   \                     Left_Motor_ON_FORWARD:
    192            if(!left_reverse_flag)                         // If left motor is not set to move backward already
   \   000000   C293....     CMP.B   #0x0, &left_reverse_flag
   \   000004   0A20         JNE     ??Left_Motor_ON_FORWARD_0
    193            {
    194              TB0CCR4 = speed*DUTY_CYCLE_DIVISOR;         // Set left motor forward speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDA03     MOV.W   R15, &0x3da
    195              left_forward_flag = true;                   // Prevent left motor from moving backward simultaneously
   \   000016   D243....     MOV.B   #0x1, &left_forward_flag
    196            }
    197          }
   \                     ??Left_Motor_ON_FORWARD_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR4_L
    198          

   \                                 In  segment CODE, align 2
    199          void Right_Motor_ON_FORWARD(uint8_t speed){
   \                     Right_Motor_ON_FORWARD:
    200            if(!right_reverse_flag)                        // If right motor is not set to move backward already
   \   000000   C293....     CMP.B   #0x0, &right_reverse_flag
   \   000004   0A20         JNE     ??Right_Motor_ON_FORWARD_0
    201            { 
    202              TB0CCR6 = speed*DUTY_CYCLE_DIVISOR;         // Set right motor forward speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDE03     MOV.W   R15, &0x3de
    203              right_forward_flag = true;                  // Prevent right motor from moving backward simultaneously
   \   000016   D243....     MOV.B   #0x1, &right_forward_flag
    204            }
    205          }
   \                     ??Right_Motor_ON_FORWARD_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR6_L
    206          

   \                                 In  segment CODE, align 2
    207          void Drive_Straight_Forward(uint8_t speed){
   \                     Drive_Straight_Forward:
   \   000000   4D4C         MOV.B   R12, R13
    208            Left_Motor_ON_FORWARD(speed);
   \   000002   4C4D         MOV.B   R13, R12
   \   000004   ........     CALLA   #Left_Motor_ON_FORWARD
    209            Right_Motor_ON_FORWARD(speed);
   \   000008   4C4D         MOV.B   R13, R12
   \   00000A   ........     BRA     #Right_Motor_ON_FORWARD
    210          }
    211            
    212          //**********
    213          // Reverse *
    214          //**********

   \                                 In  segment CODE, align 2
    215          void Left_Motor_ON_REVERSE(uint8_t speed){
   \                     Left_Motor_ON_REVERSE:
    216            if(!left_forward_flag)                        // If left motor is not set to move forward already
   \   000000   C293....     CMP.B   #0x0, &left_forward_flag
   \   000004   0A20         JNE     ??Left_Motor_ON_REVERSE_0
    217            { 
    218              TB0CCR3 = speed*DUTY_CYCLE_DIVISOR;         // Set left motor reverse speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FD803     MOV.W   R15, &0x3d8
    219              left_reverse_flag = true;                   // Prevent left motor from moving forward simultaneously
   \   000016   D243....     MOV.B   #0x1, &left_reverse_flag
    220            }
    221          }
   \                     ??Left_Motor_ON_REVERSE_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR3_L
    222          

   \                                 In  segment CODE, align 2
    223          void Right_Motor_ON_REVERSE(char speed){
   \                     Right_Motor_ON_REVERSE:
    224            if(!right_forward_flag)                       // If right motor is not set to move forward already
   \   000000   C293....     CMP.B   #0x0, &right_forward_flag
   \   000004   0A20         JNE     ??Right_Motor_ON_REVERSE_0
    225            {
    226              TB0CCR5 = speed*DUTY_CYCLE_DIVISOR;         // Set right motor reverse speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDC03     MOV.W   R15, &0x3dc
    227              right_reverse_flag = true;                  // Prevent right motor from moving forward simultaneously
   \   000016   D243....     MOV.B   #0x1, &right_reverse_flag
    228            }
    229          }
   \                     ??Right_Motor_ON_REVERSE_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR5_L
    230          

   \                                 In  segment CODE, align 2
    231          void turn(uint8_t degrees){
   \                     turn:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   484C         MOV.B   R12, R8
    232            uint32_t time_ms_temp;
    233            
    234            if(degrees == LEAVE_COURSE)
   \   000004   78902D00     CMP.B   #0x2d, R8
   \   000008   3A20         JNE     ??turn_8
    235            {
    236              time_ms_temp = time_ms;
   \   00000A   1A42....     MOV.W   &time_ms, R10
   \   00000E   1B42....     MOV.W   &time_ms + 2, R11
    237              LCD_print(" Exiting  ", word2, word3, word4);
   \   000012   1F42....     MOV.W   &word4, R15
   \   000016   1E42....     MOV.W   &word3, R14
   \   00001A   1D42....     MOV.W   &word2, R13
   \   00001E   3C40....     MOV.W   #`?<Constant " Exiting  ">`, R12
   \   000022   ........     CALLA   #LCD_print
    238              Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   000026   7C40EB00     MOV.B   #0xeb, R12
   \   00002A   ........     CALLA   #Left_Motor_ON_FORWARD
    239              Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   00002E   7C409100     MOV.B   #0x91, R12
   \   000032   ........     CALLA   #Right_Motor_ON_FORWARD
    240              while(time_ms - time_ms_temp < EXIT_TIME);     // Drive forward for x seconds
   \                     ??turn_0:
   \   000036   1E42....     MOV.W   &time_ms, R14
   \   00003A   1F42....     MOV.W   &time_ms + 2, R15
   \   00003E   0E8A         SUB.W   R10, R14
   \   000040   0F7B         SUBC.W  R11, R15
   \   000042   0F93         CMP.W   #0x0, R15
   \   000044   F82B         JNC     ??turn_0
   \   000046   0320         JNE     ??turn_9
   \   000048   3E908813     CMP.W   #0x1388, R14
   \   00004C   F42B         JNC     ??turn_0
    241          
    242              Wheels_OFF();                                  // Stop car
   \                     ??turn_9:
   \   00004E   ........     CALLA   #Wheels_OFF
    243              TA0CCTL0 &= ~CCIE;                             // Disable timer interrupts
   \   000052   B2C010004203 BIC.W   #0x10, &0x342
    244              TA0CCTL1 &= ~CCIE;                             // Disable button interrupts
   \   000058   B2C010004403 BIC.W   #0x10, &0x344
    245              LCD_print("P10 Finit ", word2, "  ^____^  ", "          ");
   \   00005E   3F40....     MOV.W   #`?<Constant "          ">`, R15
   \   000062   3E40....     MOV.W   #`?<Constant "  ^____^  ">`, R14
   \   000066   1D42....     MOV.W   &word2, R13
   \   00006A   3C40....     MOV.W   #`?<Constant "P10 Finit ">`, R12
   \   00006E   ........     CALLA   #LCD_print
    246              waiting = true;
   \   000072   D243....     MOV.B   #0x1, &waiting
    247              while(waiting);                                // Do nothing
   \                     ??turn_1:
   \   000076   C293....     CMP.B   #0x0, &waiting
   \   00007A   FD23         JNE     ??turn_1
   \   00007C   613C         JMP     ??turn_7
    248            }
    249            else
    250            {
    251              delay_time = LONG_DELAY;
   \                     ??turn_8:
   \   00007E   B240EE02.... MOV.W   #0x2ee, &delay_time
    252              Wheels_OFF();
   \   000084   ........     CALLA   #Wheels_OFF
    253              waiting = true;
   \   000088   D243....     MOV.B   #0x1, &waiting
    254              TA0CCTL2 |= CCIE;
   \   00008C   B2D010004603 BIS.W   #0x10, &0x346
    255              while(waiting);
   \                     ??turn_2:
   \   000092   C293....     CMP.B   #0x0, &waiting
   \   000096   FD23         JNE     ??turn_2
    256              delay_time = SHORT_DELAY;
   \   000098   B240FA00.... MOV.W   #0xfa, &delay_time
    257              LCD_print("", word2, word3, word4);
   \   00009E   1F42....     MOV.W   &word4, R15
   \   0000A2   1E42....     MOV.W   &word3, R14
   \   0000A6   1D42....     MOV.W   &word2, R13
   \   0000AA   3C40....     MOV.W   #`?<Constant "">`, R12
   \   0000AE   ........     CALLA   #LCD_print
    258              Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   0000B2   7C40EB00     MOV.B   #0xeb, R12
   \   0000B6   ........     CALLA   #Left_Motor_ON_FORWARD
    259              Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   0000BA   7C409100     MOV.B   #0x91, R12
   \   0000BE   ........     CALLA   #Right_Motor_ON_FORWARD
    260              waiting = true;
   \   0000C2   D243....     MOV.B   #0x1, &waiting
    261              TA0CCTL2 |= CCIE;
   \   0000C6   B2D010004603 BIS.W   #0x10, &0x346
    262              while(waiting);
   \                     ??turn_3:
   \   0000CC   C293....     CMP.B   #0x0, &waiting
   \   0000D0   FD23         JNE     ??turn_3
    263              delay_time = SHORT_DELAY;
   \   0000D2   B240FA00.... MOV.W   #0xfa, &delay_time
    264              Wheels_OFF();
   \   0000D8   ........     CALLA   #Wheels_OFF
    265              waiting = true;
   \   0000DC   D243....     MOV.B   #0x1, &waiting
    266              TA0CCTL2 |= CCIE;
   \   0000E0   B2D010004603 BIS.W   #0x10, &0x346
    267              while(waiting);
   \                     ??turn_4:
   \   0000E6   C293....     CMP.B   #0x0, &waiting
   \   0000EA   FD23         JNE     ??turn_4
    268              delay_time = LONG_DELAY;
   \   0000EC   B240EE02.... MOV.W   #0x2ee, &delay_time
    269              LCD_print("Turning in", word2, word3, word4);
   \   0000F2   1F42....     MOV.W   &word4, R15
   \   0000F6   1E42....     MOV.W   &word3, R14
   \   0000FA   1D42....     MOV.W   &word2, R13
   \   0000FE   3C40....     MOV.W   #`?<Constant "Turning in">`, R12
   \   000102   ........     CALLA   #LCD_print
    270              Left_Motor_ON_REVERSE(LEFT_SPIN_SPEED);
   \   000106   7C40FD00     MOV.B   #0xfd, R12
   \   00010A   ........     CALLA   #Left_Motor_ON_REVERSE
    271              Right_Motor_ON_FORWARD(RIGHT_SPIN_SPEED);
   \   00010E   7C40FD00     MOV.B   #0xfd, R12
   \   000112   ........     CALLA   #Right_Motor_ON_FORWARD
    272              waiting = true;
   \   000116   D243....     MOV.B   #0x1, &waiting
    273              TA0CCTL2 |= CCIE;
   \   00011A   B2D010004603 BIS.W   #0x10, &0x346
    274              while(waiting);
   \                     ??turn_5:
   \   000120   C293....     CMP.B   #0x0, &waiting
   \   000124   FD23         JNE     ??turn_5
    275              delay_time = SHORT_DELAY;
   \   000126   B240FA00.... MOV.W   #0xfa, &delay_time
    276              Wheels_OFF();
   \   00012C   ........     CALLA   #Wheels_OFF
    277              waiting = true;
   \   000130   D243....     MOV.B   #0x1, &waiting
    278              TA0CCTL2 |= CCIE;
   \   000134   B2D010004603 BIS.W   #0x10, &0x346
    279              while(waiting);
   \                     ??turn_6:
   \   00013A   C293....     CMP.B   #0x0, &waiting
   \   00013E   FD23         JNE     ??turn_6
    280            }
    281          }
   \                     ??turn_7:
   \   000140   3817         POPM.W  #0x4, R11
   \   000142   1001         RETA
   \   000144                REQUIRE _A_TA0CCTL0_L
   \   000144                REQUIRE _A_TA0CCTL1_L
   \   000144                REQUIRE _A_TA0CCTL2_L
    282          

   \                                 In  segment CODE, align 2
    283          void drive_to_black_line(void){
   \                     drive_to_black_line:
    284            LCD_print("Searching ", word2, word3, word4);
   \   000000   1F42....     MOV.W   &word4, R15
   \   000004   1E42....     MOV.W   &word3, R14
   \   000008   1D42....     MOV.W   &word2, R13
   \   00000C   3C40....     MOV.W   #`?<Constant "Searching ">`, R12
   \   000010   ........     CALLA   #LCD_print
    285            Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
   \   000014   7C40EB00     MOV.B   #0xeb, R12
   \   000018   ........     CALLA   #Left_Motor_ON_FORWARD
    286            Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
   \   00001C   7C409100     MOV.B   #0x91, R12
   \   000020   ........     CALLA   #Right_Motor_ON_FORWARD
    287            while(ADC_Left_Detector < IR_ACTIVE_READING
    288               && ADC_Right_Detector < IR_ACTIVE_READING)
   \                     ??drive_to_black_line_1:
   \   000024   B2901405.... CMP.W   #0x514, &ADC_Left_Detector
   \   00002A   0B2C         JC      ??drive_to_black_line_3
   \   00002C   B2901405.... CMP.W   #0x514, &ADC_Right_Detector
   \   000032   072C         JC      ??drive_to_black_line_3
    289            {
    290              while(ADC12CTL0 & ADC12BUSY);
   \                     ??drive_to_black_line_0:
   \   000034   92B30008     BIT.W   #0x1, &0x800
   \   000038   FD2F         JC      ??drive_to_black_line_0
    291              ADC12IER0  |= (ADC12IE2     | // Enable interrupts for new sample results
    292                             ADC12IE4     |
    293                             ADC12IE5);
   \   00003A   B2D034001208 BIS.W   #0x34, &0x812
   \   000040   F13F         JMP     ??drive_to_black_line_1
    294            }
    295            Wheels_OFF();
   \                     ??drive_to_black_line_3:
   \   000042   ........     CALLA   #Wheels_OFF
    296            delay_time = HALF_SEC;
   \   000046   B2400A00.... MOV.W   #0xa, &delay_time
    297            waiting = true;
   \   00004C   D243....     MOV.B   #0x1, &waiting
    298            TA0CCTL2 |= CCIE;
   \   000050   B2D010004603 BIS.W   #0x10, &0x346
    299            while(waiting);
   \                     ??drive_to_black_line_2:
   \   000056   C293....     CMP.B   #0x0, &waiting
   \   00005A   FD23         JNE     ??drive_to_black_line_2
    300          }
   \   00005C   1001         RETA
   \   00005E                REQUIRE _A_ADC12CTL0_L
   \   00005E                REQUIRE _A_ADC12IER0_L
   \   00005E                REQUIRE _A_TA0CCTL2_L

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  White   ">`:
   \   000000   202057686974 DC8 "  White   "
   \            6520202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " Exiting  ">`:
   \   000000   204578697469 DC8 " Exiting  "
   \            6E67202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "P10 Finit ">`:
   \   000000   503130204669 DC8 "P10 Finit "
   \            6E69742000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "  ^____^  ">`:
   \   000000   20205E5F5F5F DC8 "  ^____^  "
   \            5F5E202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "">`:
   \   000000   00           DC8 ""

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Turning in">`:
   \   000000   5475726E696E DC8 "Turning in"
   \            6720696E00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Searching ">`:
   \   000000   536561726368 DC8 "Searching "
   \            696E672000  
    301            
    302            
    303            
    304            
    305            
    306            
    307            
    308            
    309            
    310              //Backup Code 
    311            /*
    312            if(ADC_Left_Detector < ir_active_reading && ADC_Right_Detector > ir_active_reading)
    313            {
    314              left_pwm += 120;
    315              if(left_pwm > L_PWM_MAX)
    316              left_pwm = L_PWM_MAX;
    317              Left_Motor_ON_FORWARD(left_pwm);
    318              right_pwm -= 100;
    319              if(right_pwm < R_PWM_MIN)
    320              right_pwm = R_PWM_MIN;
    321              Right_Motor_ON_FORWARD(right_pwm);
    322            }
    323            else
    324            {
    325              right_pwm += 160;
    326              if(right_pwm > R_PWM_MAX)
    327              right_pwm = R_PWM_MAX;
    328              Right_Motor_ON_FORWARD(right_pwm);
    329              left_pwm -= 120;
    330              if(left_pwm < L_PWM_MIN)
    331              left_pwm = L_PWM_MIN;
    332              Left_Motor_ON_FORWARD(left_pwm);
    333            }
    334          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive_Straight_Forward
        4   -> Left_Motor_ON_FORWARD
        0   -> Right_Motor_ON_FORWARD
      4   Init_PID
      4   Left_Motor_OFF
      4   Left_Motor_ON_FORWARD
      4   Left_Motor_ON_REVERSE
      4   Right_Motor_OFF
      4   Right_Motor_ON_FORWARD
      4   Right_Motor_ON_REVERSE
      4   Wheels_OFF
        4   -> Left_Motor_OFF
        0   -> Right_Motor_OFF
      4   drive_to_black_line
        4   -> LCD_print
        4   -> Left_Motor_ON_FORWARD
        4   -> Right_Motor_ON_FORWARD
        4   -> Wheels_OFF
      4   initialize_delay
      4   pid_udpate_left
        4   -> Left_Motor_ON_FORWARD
        0   -> Right_Motor_ON_FORWARD
        4   -> Right_Motor_ON_FORWARD
     12   turn
       12   -> LCD_print
       12   -> Left_Motor_ON_FORWARD
       12   -> Left_Motor_ON_REVERSE
       12   -> Right_Motor_ON_FORWARD
       12   -> Wheels_OFF
      4   update_instruction_label


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
      11  ?<Constant "  White   ">
      11  ?<Constant "  ^____^  ">
      11  ?<Constant " Exiting  ">
       1  ?<Constant "">
      11  ?<Constant "P10 Finit ">
      11  ?<Constant "Searching ">
      11  ?<Constant "Turning in">
      14  Drive_Straight_Forward
       2  Init_PID
       1  LastDir
      20  Left_Motor_OFF
      28  Left_Motor_ON_FORWARD
      28  Left_Motor_ON_REVERSE
      20  Right_Motor_OFF
      28  Right_Motor_ON_FORWARD
      28  Right_Motor_ON_REVERSE
       8  Wheels_OFF
       2  _A_ADC12CTL0_L
       2  _A_ADC12IER0_L
       2  _A_TA0CCTL0_L
       2  _A_TA0CCTL1_L
       2  _A_TA0CCTL2_L
       2  _A_TB0CCR3_L
       2  _A_TB0CCR4_L
       2  _A_TB0CCR5_L
       2  _A_TB0CCR6_L
      94  drive_to_black_line
      12  initialize_delay
       1  instruction_label_tmp
      18  ld
       1  left_forward_flag
       2  left_pwm
       1  left_reverse_flag
     120  pid_udpate_left
      18  rd
       1  right_forward_flag
       2  right_pwm
       1  right_reverse_flag
     324  turn
      10  update_instruction_label

 
 736 bytes in segment CODE
  18 bytes in segment DATA16_AN
  78 bytes in segment DATA16_C
  46 bytes in segment DATA16_Z
 
 736 bytes of CODE  memory
  78 bytes of CONST memory
  46 bytes of DATA  memory (+ 18 bytes shared)

Errors: none
Warnings: none
