###############################################################################
#
# IAR C/C++ Compiler V7.11.1.983/W32 for MSP430           17/Apr/2018  23:30:09
# Copyright 1996-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 7.11
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\wheels.c
#    Command line  =  
#        -f C:\Users\shmes\AppData\Local\Temp\EWBB71.tmp
#        ("C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\wheels.c" -lC
#        "C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\List" -o
#        "C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5994__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  Spanish_USA.1252
#    List file     =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\List\wheels.lst
#    Object file   =  
#        C:\Users\shmes\Desktop\Escritorio
#        Personal\Escuela\ECE\306\ECE306\Project_09\Debug\Obj\wheels.r43
#
###############################################################################

C:\Users\shmes\Desktop\Escritorio Personal\Escuela\ECE\306\ECE306\Project_09\wheels.c
      1          //===============================================================
      2          //  File Name: wheels.c
      3          //  Description: This file contains the functions needed for control
      4          //                    operations of the wheels
      5          //
      6          //  Author: Sam Messick
      7          //  Date Feb. 2018
      8          //  Compiler Build with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
      9          //===============================================================
     10          
     11          #include "wheels.h"

   \                                 In  segment DATA16_AN, at 0x346
   \   union <unnamed> _A_TA0CCTL2_L
   \                     _A_TA0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d8
   \   union <unnamed> _A_TB0CCR3_L
   \                     _A_TB0CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3da
   \   union <unnamed> _A_TB0CCR4_L
   \                     _A_TB0CCR4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3dc
   \   union <unnamed> _A_TB0CCR5_L
   \                     _A_TB0CCR5_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3de
   \   union <unnamed> _A_TB0CCR6_L
   \                     _A_TB0CCR6_L:
   \   000000                DS8 2
     12          
     13          // H-bridge protection flags: 
     14          // don't allow for motion forward/backward simultaneously in one motor
     15          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          uint8_t left_forward_flag;     // Is left motor rotating forward?
   \                     left_forward_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          uint8_t left_reverse_flag;     // Is left motor rotating reverse?
   \                     left_reverse_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          uint8_t right_forward_flag;    // Is right motor rotating forward?
   \                     right_forward_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          uint8_t right_reverse_flag;    // Is right motor rotating reverse?
   \                     right_reverse_flag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          uint8_t instruction_label_tmp; // Global of current instruction step
   \                     instruction_label_tmp:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          uint8_t LastDir;
   \                     LastDir:
   \   000000                DS8 1
     22          
     23          //--------PID fields-----------//

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          int16_t   right_pwm;
   \                     right_pwm:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          int16_t   left_pwm;
   \                     left_pwm:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          PID ld; // Left infrared detector
   \                     ld:
   \   000000                DS8 18

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          PID rd;
   \                     rd:
   \   000000                DS8 18
     28          //-----------------------------//
     29          
     30          

   \                                 In  segment CODE, align 2
     31          void Init_PID(void){
   \                     Init_PID:
     32            /*
     33            ld.windup_guard = L_PWM_MAX;
     34            rd.windup_guard = R_PWM_MAX;
     35            ld.p_gain = 1.5;//((double)(ADC_Thumb))/1000;     // 1.15
     36            ld.i_gain = 0; 
     37            ld.d_gain = 6;//1.5;
     38            rd.p_gain = 3;//((double)(ADC_Thumb))/1000;
     39            rd.i_gain = 0; 
     40            rd.d_gain = 6;//1.5;
     41            right_pwm = RIGHT_FORWARD_SPEED;
     42            left_pwm = LEFT_FORWARD_SPEED;
     43          */
     44          }
   \   000000   1001         RETA
     45          /*
     46          void pid_udpate_left(void){
     47            
     48            if(ADC_Left_Detector >= ir_black_reading)
     49              if(ADC_Right_Detector >= ir_black_reading)
     50              {
     51                Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
     52                Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
     53              }
     54              else
     55              {
     56                Left_Motor_ON_FORWARD(LEFT_R_SEARCH_SPEED);
     57                Right_Motor_ON_FORWARD(RIGHT_R_SEARCH_SPEED);
     58                LastDir = LEFT;
     59              }
     60            else 
     61              if(ADC_Right_Detector >= ir_black_reading)
     62              {
     63            
     64                Left_Motor_ON_FORWARD(LEFT_L_SEARCH_SPEED);
     65                Right_Motor_ON_FORWARD(RIGHT_L_SEARCH_SPEED);
     66                LastDir = RIGHT;
     67              }
     68              else 
     69              {
     70                word4 = "  White   ";
     71                if(LastDir == LEFT)
     72                {
     73                  Left_Motor_ON_FORWARD(LEFT_R_SEARCH_SPEED);
     74                  Right_Motor_ON_FORWARD(RIGHT_R_SEARCH_SPEED);
     75                }
     76                else
     77                {
     78                  Left_Motor_ON_FORWARD(LEFT_L_SEARCH_SPEED);
     79                  Right_Motor_ON_FORWARD(RIGHT_L_SEARCH_SPEED);
     80                }
     81              }
     82            
     83            // Attempted PID
     84             Uses a PID with noise bands at ir_white_reading and 
     85             ir_black_reading, adjusting for changes to follow
     86             a black line.
     87          
     88            // Take NUM_SAMPLES from PID in pid_samples for averaging
     89            static uint8_t samp_index; 
     90            static int16_t[NUM_SAMPLES] pid_error_l_samples; 
     91            static int16_t error_l;
     92            static int16_t d_error_l;
     93            
     94            int16_t error_l_w;
     95            int16_t error_l_b;
     96            
     97            // Update PID errors
     98            error_l_w = ADC_Left_Detector - ir_white_reading;
     99            error_l_b = ADC_Left_Detector - ir_black_reading;
    100            
    101            // Check if error falls outside of noise bands
    102            if(error_l_w < 0)
    103            {
    104              error_l = error_l_w;
    105              pid_error_l_samples
    106            }
    107            else if(error_l_b > 0)
    108              error_l = error_l_b;
    109            else
    110              return;
    111            
    112            
    113            
    114            if(error_l IS_POSITIVE)
    115              P1OUT  |= RED_LED;
    116            else
    117              P1OUT  &= ~RED_LED;
    118            ld.i_error = error_l + ld.i_error;
    119            d_error_l = error_l - ld.prev_error;
    120            if(d_error_l IS_POSITIVE)
    121              P1OUT  |= GRN_LED;
    122            else
    123              P1OUT  &= ~GRN_LED;
    124            
    125            if(ld.i_error > ld.windup_guard)
    126              ld.i_error = ld.windup_guard;
    127            else if(ld.i_error < -ld.windup_guard)
    128              ld.i_error = -ld.windup_guard;
    129            
    130            // Calculate adjusted pwm
    131            left_pwm =  (uint8_t)(LEFT_FORWARD_SPEED    -
    132                        (ld.p_gain * error_l) -
    133                        (ld.i_gain * ld.i_error) -
    134                        (ld.d_gain * d_error_l));
    135            right_pwm = (uint8_t)(RIGHT_FORWARD_SPEED  +
    136                        (rd.p_gain * error_l) +
    137                        (rd.i_gain * ld.i_error) +
    138                        (rd.d_gain * d_error_l));
    139            if(left_pwm > L_PWM_MAX)
    140              left_pwm = L_PWM_MAX;
    141            if(left_pwm < L_PWM_MIN)
    142              left_pwm = L_PWM_MIN;
    143            if(right_pwm > R_PWM_MAX)
    144              right_pwm = R_PWM_MAX;
    145            if(right_pwm < R_PWM_MIN)
    146              right_pwm = R_PWM_MIN;
    147            
    148            // Enable motor
    149            Left_Motor_ON_FORWARD(left_pwm);
    150            Right_Motor_ON_FORWARD(right_pwm);
    151            
    152            ld.prev_error = error_l;
    153          
    154          }
    155          */

   \                                 In  segment CODE, align 2
    156          void initialize_delay(uint16_t delay){
   \                     initialize_delay:
    157            delay_time = delay;                          // send delay time to global accessible by timer A1
   \   000000   824C....     MOV.W   R12, &delay_time
    158            TA0CCTL2 |= CCIE;                            // enable timer A1.2 to count time
   \   000004   B2D010004603 BIS.W   #0x10, &0x346
    159          }
   \   00000A   1001         RETA
   \   00000C                REQUIRE _A_TA0CCTL2_L
    160          

   \                                 In  segment CODE, align 2
    161          void update_instruction_label(uint8_t* instruction_label){
   \                     update_instruction_label:
    162            (*instruction_label)++;                         // Set up next instruction
   \   000000   DC530000     ADD.B   #0x1, 0(R12)
    163            instruction_label_tmp = *instruction_label;   // Set static instruction visable by menu to update LCD
   \   000004   E24C....     MOV.B   @R12, &instruction_label_tmp
    164          }
   \   000008   1001         RETA
    165          
    166          void WHEELS_test(void);
    167          //------------------------
    168          // Turning wheels off
    169          //------------------------

   \                                 In  segment CODE, align 2
    170          void Left_Motor_OFF(void){
   \                     Left_Motor_OFF:
    171            TB0CCR3 = MOTOR_OFF;         // Set PWM to 0 percent duty cycle
   \   000000   8243D803     MOV.W   #0x0, &0x3d8
    172            TB0CCR4 = MOTOR_OFF;   
   \   000004   8243DA03     MOV.W   #0x0, &0x3da
    173            left_forward_flag = left_reverse_flag = false;
   \   000008   C243....     MOV.B   #0x0, &left_reverse_flag
   \   00000C   D242........ MOV.B   &left_reverse_flag, &left_forward_flag
    174          }
   \   000012   1001         RETA
   \   000014                REQUIRE _A_TB0CCR3_L
   \   000014                REQUIRE _A_TB0CCR4_L

   \                                 In  segment CODE, align 2
    175          void Right_Motor_OFF(void){
   \                     Right_Motor_OFF:
    176            TB0CCR5 = MOTOR_OFF;         // Set PWM to 0 percent duty cycle
   \   000000   8243DC03     MOV.W   #0x0, &0x3dc
    177            TB0CCR6 = MOTOR_OFF;         
   \   000004   8243DE03     MOV.W   #0x0, &0x3de
    178            right_forward_flag = right_reverse_flag = false;
   \   000008   C243....     MOV.B   #0x0, &right_reverse_flag
   \   00000C   D242........ MOV.B   &right_reverse_flag, &right_forward_flag
    179          }
   \   000012   1001         RETA
   \   000014                REQUIRE _A_TB0CCR5_L
   \   000014                REQUIRE _A_TB0CCR6_L

   \                                 In  segment CODE, align 2
    180          void Wheels_OFF(void){
   \                     Wheels_OFF:
    181            Left_Motor_OFF();
   \   000000   ........     CALLA   #Left_Motor_OFF
    182            Right_Motor_OFF();
   \   000004   ........     BRA     #Right_Motor_OFF
    183          }
    184          
    185          //------------------------
    186          // Turning wheels on
    187          //------------------------
    188          //**********
    189          // Forward *
    190          //**********

   \                                 In  segment CODE, align 2
    191          void Left_Motor_ON_FORWARD(uint8_t speed){
   \                     Left_Motor_ON_FORWARD:
    192            if(!left_reverse_flag)                         // If left motor is not set to move backward already
   \   000000   C293....     CMP.B   #0x0, &left_reverse_flag
   \   000004   0A20         JNE     ??Left_Motor_ON_FORWARD_0
    193            {
    194              TB0CCR4 = speed*DUTY_CYCLE_DIVISOR;         // Set left motor forward speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDA03     MOV.W   R15, &0x3da
    195              left_forward_flag = true;                   // Prevent left motor from moving backward simultaneously
   \   000016   D243....     MOV.B   #0x1, &left_forward_flag
    196            }
    197          }
   \                     ??Left_Motor_ON_FORWARD_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR4_L
    198          

   \                                 In  segment CODE, align 2
    199          void Right_Motor_ON_FORWARD(uint8_t speed){
   \                     Right_Motor_ON_FORWARD:
    200            if(!right_reverse_flag)                        // If right motor is not set to move backward already
   \   000000   C293....     CMP.B   #0x0, &right_reverse_flag
   \   000004   0A20         JNE     ??Right_Motor_ON_FORWARD_0
    201            { 
    202              TB0CCR6 = speed*DUTY_CYCLE_DIVISOR;         // Set right motor forward speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDE03     MOV.W   R15, &0x3de
    203              right_forward_flag = true;                  // Prevent right motor from moving backward simultaneously
   \   000016   D243....     MOV.B   #0x1, &right_forward_flag
    204            }
    205          }
   \                     ??Right_Motor_ON_FORWARD_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR6_L
    206          

   \                                 In  segment CODE, align 2
    207          void Drive_Straight_Forward(uint8_t speed){
   \                     Drive_Straight_Forward:
   \   000000   4D4C         MOV.B   R12, R13
    208            Left_Motor_ON_FORWARD(speed);
   \   000002   4C4D         MOV.B   R13, R12
   \   000004   ........     CALLA   #Left_Motor_ON_FORWARD
    209            Right_Motor_ON_FORWARD(speed);
   \   000008   4C4D         MOV.B   R13, R12
   \   00000A   ........     BRA     #Right_Motor_ON_FORWARD
    210          }
    211            
    212          //**********
    213          // Reverse *
    214          //**********

   \                                 In  segment CODE, align 2
    215          void Left_Motor_ON_REVERSE(uint8_t speed){
   \                     Left_Motor_ON_REVERSE:
    216            if(!left_forward_flag)                        // If left motor is not set to move forward already
   \   000000   C293....     CMP.B   #0x0, &left_forward_flag
   \   000004   0A20         JNE     ??Left_Motor_ON_REVERSE_0
    217            { 
    218              TB0CCR3 = speed*DUTY_CYCLE_DIVISOR;         // Set left motor reverse speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FD803     MOV.W   R15, &0x3d8
    219              left_reverse_flag = true;                   // Prevent left motor from moving forward simultaneously
   \   000016   D243....     MOV.B   #0x1, &left_reverse_flag
    220            }
    221          }
   \                     ??Left_Motor_ON_REVERSE_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR3_L
    222          

   \                                 In  segment CODE, align 2
    223          void Right_Motor_ON_REVERSE(char speed){
   \                     Right_Motor_ON_REVERSE:
    224            if(!right_forward_flag)                       // If right motor is not set to move forward already
   \   000000   C293....     CMP.B   #0x0, &right_forward_flag
   \   000004   0A20         JNE     ??Right_Motor_ON_REVERSE_0
    225            {
    226              TB0CCR5 = speed*DUTY_CYCLE_DIVISOR;         // Set right motor reverse speed as one of 255 settings
   \   000006   4F4C         MOV.B   R12, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3FF0FF00     AND.W   #0xff, R15
   \   00000E   8F10         SWPB    R15
   \   000010   0F5E         ADD.W   R14, R15
   \   000012   824FDC03     MOV.W   R15, &0x3dc
    227              right_reverse_flag = true;                  // Prevent right motor from moving forward simultaneously
   \   000016   D243....     MOV.B   #0x1, &right_reverse_flag
    228            }
    229          }
   \                     ??Right_Motor_ON_REVERSE_0:
   \   00001A   1001         RETA
   \   00001C                REQUIRE _A_TB0CCR5_L
    230          /*
    231          void turn(int8_t degrees){
    232            if(degrees IS_POSITIVE)
    233            {
    234            delay_time = LONG_DELAY;
    235            Wheels_OFF();
    236            waiting = true;
    237            TA0CCTL2 |= CCIE;
    238            while(waiting);
    239            delay_time = SHORT_DELAY;
    240            LCD_print("Driving from", "Black line", "          ", "          ");
    241            Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
    242            Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
    243            waiting = true;
    244            TA0CCTL2 |= CCIE;
    245            while(waiting);
    246            delay_time = SHORT_DELAY;
    247            Wheels_OFF();
    248            waiting = true;
    249            TA0CCTL2 |= CCIE;
    250            while(waiting);
    251            delay_time = LONG_DELAY;
    252            LCD_print("Turning in", "   Loop   ", "          ", "          ");
    253            Left_Motor_ON_REVERSE(LEFT_SPIN_SPEED);
    254            Right_Motor_ON_FORWARD(RIGHT_SPIN_SPEED);
    255            waiting = true;
    256            TA0CCTL2 |= CCIE;
    257            while(waiting);
    258            delay_time = SHORT_DELAY;
    259            Wheels_OFF();
    260            waiting = true;
    261            TA0CCTL2 |= CCIE;
    262            while(waiting);
    263            waiting= true;
    264            }
    265            if(degrees IS_NEGATIVE)
    266            {
    267            uint64_t i;  
    268            TA0CCTL0 &= ~CCIE;
    269            delay_time = SHORT_DELAY;
    270            Wheels_OFF();
    271            for(i = 0; i < 2000; i++);
    272            delay_time = LONG_DELAY;
    273            LCD_print("Turning in", "   Loop   ", "          ", "          ");
    274            Left_Motor_ON_REVERSE(LEFT_SPIN_SPEED);
    275            Right_Motor_ON_FORWARD(RIGHT_SPIN_SPEED);
    276            for(i = 0; i < 300000; i++);
    277            Wheels_OFF();
    278            delay_time = HALF_SEC;
    279            LCD_print("Driving in", "   Loop   ", "          ", "          ");
    280            Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
    281            Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
    282            for(i = 0; i < 1000000; i++);
    283            Wheels_OFF();
    284            LCD_print("          ", "   Demo   ", " Complete ", "          ");
    285            }
    286          }
    287          void drive_to_black_line(void){
    288            LCD_print("Driving to", "Black line", "          ", "          ");
    289            Left_Motor_ON_FORWARD(LEFT_FORWARD_SPEED);
    290            Right_Motor_ON_FORWARD(RIGHT_FORWARD_SPEED);
    291            while(ADC_Left_Detector < ir_black_reading
    292               && ADC_Right_Detector < ir_black_reading)
    293            {
    294              while(ADC12CTL0 & ADC12BUSY);
    295              ADC12IER0  |= (ADC12IE2     | // Enable interrupts for new sample results
    296                             ADC12IE4     |
    297                             ADC12IE5);
    298            }
    299            Wheels_OFF();
    300            delay_time = HALF_SEC;
    301            waiting = true;
    302            TA0CCTL2 |= CCIE;
    303            while(waiting);
    304          }
    305            
    306          */
    307            
    308            
    309            
    310            
    311            
    312            
    313            
    314            
    315            
    316              //Backup Code 
    317            /*
    318            if(ADC_Left_Detector < ir_active_reading && ADC_Right_Detector > ir_active_reading)
    319            {
    320              left_pwm += 120;
    321              if(left_pwm > L_PWM_MAX)
    322              left_pwm = L_PWM_MAX;
    323              Left_Motor_ON_FORWARD(left_pwm);
    324              right_pwm -= 100;
    325              if(right_pwm < R_PWM_MIN)
    326              right_pwm = R_PWM_MIN;
    327              Right_Motor_ON_FORWARD(right_pwm);
    328            }
    329            else
    330            {
    331              right_pwm += 160;
    332              if(right_pwm > R_PWM_MAX)
    333              right_pwm = R_PWM_MAX;
    334              Right_Motor_ON_FORWARD(right_pwm);
    335              left_pwm -= 120;
    336              if(left_pwm < L_PWM_MIN)
    337              left_pwm = L_PWM_MIN;
    338              Left_Motor_ON_FORWARD(left_pwm);
    339            }
    340          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive_Straight_Forward
        4   -> Left_Motor_ON_FORWARD
        0   -> Right_Motor_ON_FORWARD
      4   Init_PID
      4   Left_Motor_OFF
      4   Left_Motor_ON_FORWARD
      4   Left_Motor_ON_REVERSE
      4   Right_Motor_OFF
      4   Right_Motor_ON_FORWARD
      4   Right_Motor_ON_REVERSE
      4   Wheels_OFF
        4   -> Left_Motor_OFF
        0   -> Right_Motor_OFF
      4   initialize_delay
      4   update_instruction_label


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      14  Drive_Straight_Forward
       2  Init_PID
       1  LastDir
      20  Left_Motor_OFF
      28  Left_Motor_ON_FORWARD
      28  Left_Motor_ON_REVERSE
      20  Right_Motor_OFF
      28  Right_Motor_ON_FORWARD
      28  Right_Motor_ON_REVERSE
       8  Wheels_OFF
       2  _A_TA0CCTL2_L
       2  _A_TB0CCR3_L
       2  _A_TB0CCR4_L
       2  _A_TB0CCR5_L
       2  _A_TB0CCR6_L
      12  initialize_delay
       1  instruction_label_tmp
      18  ld
       1  left_forward_flag
       2  left_pwm
       1  left_reverse_flag
      18  rd
       1  right_forward_flag
       2  right_pwm
       1  right_reverse_flag
      10  update_instruction_label

 
 198 bytes in segment CODE
  10 bytes in segment DATA16_AN
  46 bytes in segment DATA16_Z
 
 198 bytes of CODE memory
  46 bytes of DATA memory (+ 10 bytes shared)

Errors: none
Warnings: none
